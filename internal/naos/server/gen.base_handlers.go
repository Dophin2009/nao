// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package server

import (
	"encoding/json"
	"io/ioutil"
	"net/http"
	"strings"

	"github.com/julienschmidt/httprouter"
	"gitlab.com/Dophin2009/nao/pkg/api"
	"gitlab.com/Dophin2009/nao/pkg/data"
)

// Media is a generic placeholder for all entity types;
// it is assumed that Media structs have an ID and Version,

// MediaHandlerGroup is a basic handler group for Media
type MediaHandlerGroup struct {
	Service *data.MediaService
}

// NewMediaHandlerGroup returns a handler group for
// Media with the given service
func NewMediaHandlerGroup(service *data.MediaService) MediaHandlerGroup {
	g := MediaHandlerGroup{
		Service: service,
	}
	return g
}

// Handlers returns all the basic CRUD handlers for the
// handler group
func (g *MediaHandlerGroup) Handlers() []Handler {
	return []Handler{
		g.CreateHandler(),
		g.UpdateHandler(),
		g.DeleteHandler(),
		g.GetAllHandler(),
		g.GetByIDHandler(),
	}
}

// CreateHandler returns an POST endpoint handler
// for creating new Media
func (g *MediaHandlerGroup) CreateHandler() Handler {
	return Handler{
		Method: http.MethodPost,
		Path:   []string{strings.ToLower("Media")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into Media
			var e data.Media
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed Media
			err = g.Service.Create(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// UpdateHandler returns a PUT endpoint handler for
// updaing the Media with the given id (path variable :id)
func (g *MediaHandlerGroup) UpdateHandler() Handler {
	return Handler{
		Method: http.MethodPut,
		Path:   []string{strings.ToLower("Media"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into Media
			var e data.Media
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed Media
			err = g.Service.Update(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// DeleteHandler returns a DELETE endpoint handler for
// deleting the Media at the given id (path variable :id)
func (g *MediaHandlerGroup) DeleteHandler() Handler {
	return Handler{
		Method: http.MethodDelete,
		Path:   []string{strings.ToLower("Media"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Delete by ID and retrieve existing
			e, err := g.Service.Delete(id)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)

		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetAllHandler returns a GET endpoint handler for
// retrieving all Media
func (g *MediaHandlerGroup) GetAllHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("Media")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Retrieve all Media
			list, err := g.Service.GetAll()
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}
			if list == nil {
				list = []data.Media{}
			}

			// Encode response
			encodeResponseBody(list, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetByIDHandler returns a GET endpoint handler for
// retrieving a single Media by the given id (path
// variable :id)
func (g *MediaHandlerGroup) GetByIDHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("Media"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID from path
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Retrieve Media by ID
			e := data.Media{
				ID: id,
			}
			err = g.Service.GetByID(&e)
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// Episode is a generic placeholder for all entity types;
// it is assumed that Episode structs have an ID and Version,

// EpisodeHandlerGroup is a basic handler group for Episode
type EpisodeHandlerGroup struct {
	Service *data.EpisodeService
}

// NewEpisodeHandlerGroup returns a handler group for
// Episode with the given service
func NewEpisodeHandlerGroup(service *data.EpisodeService) EpisodeHandlerGroup {
	g := EpisodeHandlerGroup{
		Service: service,
	}
	return g
}

// Handlers returns all the basic CRUD handlers for the
// handler group
func (g *EpisodeHandlerGroup) Handlers() []Handler {
	return []Handler{
		g.CreateHandler(),
		g.UpdateHandler(),
		g.DeleteHandler(),
		g.GetAllHandler(),
		g.GetByIDHandler(),
	}
}

// CreateHandler returns an POST endpoint handler
// for creating new Episode
func (g *EpisodeHandlerGroup) CreateHandler() Handler {
	return Handler{
		Method: http.MethodPost,
		Path:   []string{strings.ToLower("Episode")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into Episode
			var e data.Episode
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed Episode
			err = g.Service.Create(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// UpdateHandler returns a PUT endpoint handler for
// updaing the Episode with the given id (path variable :id)
func (g *EpisodeHandlerGroup) UpdateHandler() Handler {
	return Handler{
		Method: http.MethodPut,
		Path:   []string{strings.ToLower("Episode"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into Episode
			var e data.Episode
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed Episode
			err = g.Service.Update(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// DeleteHandler returns a DELETE endpoint handler for
// deleting the Episode at the given id (path variable :id)
func (g *EpisodeHandlerGroup) DeleteHandler() Handler {
	return Handler{
		Method: http.MethodDelete,
		Path:   []string{strings.ToLower("Episode"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Delete by ID and retrieve existing
			e, err := g.Service.Delete(id)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)

		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetAllHandler returns a GET endpoint handler for
// retrieving all Episode
func (g *EpisodeHandlerGroup) GetAllHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("Episode")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Retrieve all Episode
			list, err := g.Service.GetAll()
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}
			if list == nil {
				list = []data.Episode{}
			}

			// Encode response
			encodeResponseBody(list, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetByIDHandler returns a GET endpoint handler for
// retrieving a single Episode by the given id (path
// variable :id)
func (g *EpisodeHandlerGroup) GetByIDHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("Episode"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID from path
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Retrieve Episode by ID
			e := data.Episode{
				ID: id,
			}
			err = g.Service.GetByID(&e)
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// Character is a generic placeholder for all entity types;
// it is assumed that Character structs have an ID and Version,

// CharacterHandlerGroup is a basic handler group for Character
type CharacterHandlerGroup struct {
	Service *data.CharacterService
}

// NewCharacterHandlerGroup returns a handler group for
// Character with the given service
func NewCharacterHandlerGroup(service *data.CharacterService) CharacterHandlerGroup {
	g := CharacterHandlerGroup{
		Service: service,
	}
	return g
}

// Handlers returns all the basic CRUD handlers for the
// handler group
func (g *CharacterHandlerGroup) Handlers() []Handler {
	return []Handler{
		g.CreateHandler(),
		g.UpdateHandler(),
		g.DeleteHandler(),
		g.GetAllHandler(),
		g.GetByIDHandler(),
	}
}

// CreateHandler returns an POST endpoint handler
// for creating new Character
func (g *CharacterHandlerGroup) CreateHandler() Handler {
	return Handler{
		Method: http.MethodPost,
		Path:   []string{strings.ToLower("Character")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into Character
			var e data.Character
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed Character
			err = g.Service.Create(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// UpdateHandler returns a PUT endpoint handler for
// updaing the Character with the given id (path variable :id)
func (g *CharacterHandlerGroup) UpdateHandler() Handler {
	return Handler{
		Method: http.MethodPut,
		Path:   []string{strings.ToLower("Character"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into Character
			var e data.Character
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed Character
			err = g.Service.Update(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// DeleteHandler returns a DELETE endpoint handler for
// deleting the Character at the given id (path variable :id)
func (g *CharacterHandlerGroup) DeleteHandler() Handler {
	return Handler{
		Method: http.MethodDelete,
		Path:   []string{strings.ToLower("Character"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Delete by ID and retrieve existing
			e, err := g.Service.Delete(id)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)

		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetAllHandler returns a GET endpoint handler for
// retrieving all Character
func (g *CharacterHandlerGroup) GetAllHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("Character")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Retrieve all Character
			list, err := g.Service.GetAll()
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}
			if list == nil {
				list = []data.Character{}
			}

			// Encode response
			encodeResponseBody(list, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetByIDHandler returns a GET endpoint handler for
// retrieving a single Character by the given id (path
// variable :id)
func (g *CharacterHandlerGroup) GetByIDHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("Character"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID from path
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Retrieve Character by ID
			e := data.Character{
				ID: id,
			}
			err = g.Service.GetByID(&e)
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// Genre is a generic placeholder for all entity types;
// it is assumed that Genre structs have an ID and Version,

// GenreHandlerGroup is a basic handler group for Genre
type GenreHandlerGroup struct {
	Service *data.GenreService
}

// NewGenreHandlerGroup returns a handler group for
// Genre with the given service
func NewGenreHandlerGroup(service *data.GenreService) GenreHandlerGroup {
	g := GenreHandlerGroup{
		Service: service,
	}
	return g
}

// Handlers returns all the basic CRUD handlers for the
// handler group
func (g *GenreHandlerGroup) Handlers() []Handler {
	return []Handler{
		g.CreateHandler(),
		g.UpdateHandler(),
		g.DeleteHandler(),
		g.GetAllHandler(),
		g.GetByIDHandler(),
	}
}

// CreateHandler returns an POST endpoint handler
// for creating new Genre
func (g *GenreHandlerGroup) CreateHandler() Handler {
	return Handler{
		Method: http.MethodPost,
		Path:   []string{strings.ToLower("Genre")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into Genre
			var e data.Genre
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed Genre
			err = g.Service.Create(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// UpdateHandler returns a PUT endpoint handler for
// updaing the Genre with the given id (path variable :id)
func (g *GenreHandlerGroup) UpdateHandler() Handler {
	return Handler{
		Method: http.MethodPut,
		Path:   []string{strings.ToLower("Genre"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into Genre
			var e data.Genre
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed Genre
			err = g.Service.Update(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// DeleteHandler returns a DELETE endpoint handler for
// deleting the Genre at the given id (path variable :id)
func (g *GenreHandlerGroup) DeleteHandler() Handler {
	return Handler{
		Method: http.MethodDelete,
		Path:   []string{strings.ToLower("Genre"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Delete by ID and retrieve existing
			e, err := g.Service.Delete(id)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)

		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetAllHandler returns a GET endpoint handler for
// retrieving all Genre
func (g *GenreHandlerGroup) GetAllHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("Genre")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Retrieve all Genre
			list, err := g.Service.GetAll()
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}
			if list == nil {
				list = []data.Genre{}
			}

			// Encode response
			encodeResponseBody(list, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetByIDHandler returns a GET endpoint handler for
// retrieving a single Genre by the given id (path
// variable :id)
func (g *GenreHandlerGroup) GetByIDHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("Genre"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID from path
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Retrieve Genre by ID
			e := data.Genre{
				ID: id,
			}
			err = g.Service.GetByID(&e)
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// Producer is a generic placeholder for all entity types;
// it is assumed that Producer structs have an ID and Version,

// ProducerHandlerGroup is a basic handler group for Producer
type ProducerHandlerGroup struct {
	Service *data.ProducerService
}

// NewProducerHandlerGroup returns a handler group for
// Producer with the given service
func NewProducerHandlerGroup(service *data.ProducerService) ProducerHandlerGroup {
	g := ProducerHandlerGroup{
		Service: service,
	}
	return g
}

// Handlers returns all the basic CRUD handlers for the
// handler group
func (g *ProducerHandlerGroup) Handlers() []Handler {
	return []Handler{
		g.CreateHandler(),
		g.UpdateHandler(),
		g.DeleteHandler(),
		g.GetAllHandler(),
		g.GetByIDHandler(),
	}
}

// CreateHandler returns an POST endpoint handler
// for creating new Producer
func (g *ProducerHandlerGroup) CreateHandler() Handler {
	return Handler{
		Method: http.MethodPost,
		Path:   []string{strings.ToLower("Producer")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into Producer
			var e data.Producer
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed Producer
			err = g.Service.Create(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// UpdateHandler returns a PUT endpoint handler for
// updaing the Producer with the given id (path variable :id)
func (g *ProducerHandlerGroup) UpdateHandler() Handler {
	return Handler{
		Method: http.MethodPut,
		Path:   []string{strings.ToLower("Producer"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into Producer
			var e data.Producer
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed Producer
			err = g.Service.Update(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// DeleteHandler returns a DELETE endpoint handler for
// deleting the Producer at the given id (path variable :id)
func (g *ProducerHandlerGroup) DeleteHandler() Handler {
	return Handler{
		Method: http.MethodDelete,
		Path:   []string{strings.ToLower("Producer"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Delete by ID and retrieve existing
			e, err := g.Service.Delete(id)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)

		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetAllHandler returns a GET endpoint handler for
// retrieving all Producer
func (g *ProducerHandlerGroup) GetAllHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("Producer")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Retrieve all Producer
			list, err := g.Service.GetAll()
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}
			if list == nil {
				list = []data.Producer{}
			}

			// Encode response
			encodeResponseBody(list, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetByIDHandler returns a GET endpoint handler for
// retrieving a single Producer by the given id (path
// variable :id)
func (g *ProducerHandlerGroup) GetByIDHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("Producer"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID from path
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Retrieve Producer by ID
			e := data.Producer{
				ID: id,
			}
			err = g.Service.GetByID(&e)
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// Person is a generic placeholder for all entity types;
// it is assumed that Person structs have an ID and Version,

// PersonHandlerGroup is a basic handler group for Person
type PersonHandlerGroup struct {
	Service *data.PersonService
}

// NewPersonHandlerGroup returns a handler group for
// Person with the given service
func NewPersonHandlerGroup(service *data.PersonService) PersonHandlerGroup {
	g := PersonHandlerGroup{
		Service: service,
	}
	return g
}

// Handlers returns all the basic CRUD handlers for the
// handler group
func (g *PersonHandlerGroup) Handlers() []Handler {
	return []Handler{
		g.CreateHandler(),
		g.UpdateHandler(),
		g.DeleteHandler(),
		g.GetAllHandler(),
		g.GetByIDHandler(),
	}
}

// CreateHandler returns an POST endpoint handler
// for creating new Person
func (g *PersonHandlerGroup) CreateHandler() Handler {
	return Handler{
		Method: http.MethodPost,
		Path:   []string{strings.ToLower("Person")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into Person
			var e data.Person
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed Person
			err = g.Service.Create(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// UpdateHandler returns a PUT endpoint handler for
// updaing the Person with the given id (path variable :id)
func (g *PersonHandlerGroup) UpdateHandler() Handler {
	return Handler{
		Method: http.MethodPut,
		Path:   []string{strings.ToLower("Person"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into Person
			var e data.Person
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed Person
			err = g.Service.Update(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// DeleteHandler returns a DELETE endpoint handler for
// deleting the Person at the given id (path variable :id)
func (g *PersonHandlerGroup) DeleteHandler() Handler {
	return Handler{
		Method: http.MethodDelete,
		Path:   []string{strings.ToLower("Person"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Delete by ID and retrieve existing
			e, err := g.Service.Delete(id)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)

		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetAllHandler returns a GET endpoint handler for
// retrieving all Person
func (g *PersonHandlerGroup) GetAllHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("Person")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Retrieve all Person
			list, err := g.Service.GetAll()
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}
			if list == nil {
				list = []data.Person{}
			}

			// Encode response
			encodeResponseBody(list, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetByIDHandler returns a GET endpoint handler for
// retrieving a single Person by the given id (path
// variable :id)
func (g *PersonHandlerGroup) GetByIDHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("Person"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID from path
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Retrieve Person by ID
			e := data.Person{
				ID: id,
			}
			err = g.Service.GetByID(&e)
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// User is a generic placeholder for all entity types;
// it is assumed that User structs have an ID and Version,

// UserHandlerGroup is a basic handler group for User
type UserHandlerGroup struct {
	Service *data.UserService
}

// NewUserHandlerGroup returns a handler group for
// User with the given service
func NewUserHandlerGroup(service *data.UserService) UserHandlerGroup {
	g := UserHandlerGroup{
		Service: service,
	}
	return g
}

// Handlers returns all the basic CRUD handlers for the
// handler group
func (g *UserHandlerGroup) Handlers() []Handler {
	return []Handler{
		g.CreateHandler(),
		g.UpdateHandler(),
		g.DeleteHandler(),
		g.GetAllHandler(),
		g.GetByIDHandler(),
	}
}

// CreateHandler returns an POST endpoint handler
// for creating new User
func (g *UserHandlerGroup) CreateHandler() Handler {
	return Handler{
		Method: http.MethodPost,
		Path:   []string{strings.ToLower("User")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into User
			var e data.User
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed User
			err = g.Service.Create(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// UpdateHandler returns a PUT endpoint handler for
// updaing the User with the given id (path variable :id)
func (g *UserHandlerGroup) UpdateHandler() Handler {
	return Handler{
		Method: http.MethodPut,
		Path:   []string{strings.ToLower("User"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into User
			var e data.User
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed User
			err = g.Service.Update(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// DeleteHandler returns a DELETE endpoint handler for
// deleting the User at the given id (path variable :id)
func (g *UserHandlerGroup) DeleteHandler() Handler {
	return Handler{
		Method: http.MethodDelete,
		Path:   []string{strings.ToLower("User"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Delete by ID and retrieve existing
			e, err := g.Service.Delete(id)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)

		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetAllHandler returns a GET endpoint handler for
// retrieving all User
func (g *UserHandlerGroup) GetAllHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("User")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Retrieve all User
			list, err := g.Service.GetAll()
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}
			if list == nil {
				list = []data.User{}
			}

			// Encode response
			encodeResponseBody(list, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetByIDHandler returns a GET endpoint handler for
// retrieving a single User by the given id (path
// variable :id)
func (g *UserHandlerGroup) GetByIDHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("User"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID from path
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Retrieve User by ID
			e := data.User{
				ID: id,
			}
			err = g.Service.GetByID(&e)
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// MediaRelation is a generic placeholder for all entity types;
// it is assumed that MediaRelation structs have an ID and Version,

// MediaRelationHandlerGroup is a basic handler group for MediaRelation
type MediaRelationHandlerGroup struct {
	Service *data.MediaRelationService
}

// NewMediaRelationHandlerGroup returns a handler group for
// MediaRelation with the given service
func NewMediaRelationHandlerGroup(service *data.MediaRelationService) MediaRelationHandlerGroup {
	g := MediaRelationHandlerGroup{
		Service: service,
	}
	return g
}

// Handlers returns all the basic CRUD handlers for the
// handler group
func (g *MediaRelationHandlerGroup) Handlers() []Handler {
	return []Handler{
		g.CreateHandler(),
		g.UpdateHandler(),
		g.DeleteHandler(),
		g.GetAllHandler(),
		g.GetByIDHandler(),
	}
}

// CreateHandler returns an POST endpoint handler
// for creating new MediaRelation
func (g *MediaRelationHandlerGroup) CreateHandler() Handler {
	return Handler{
		Method: http.MethodPost,
		Path:   []string{strings.ToLower("MediaRelation")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into MediaRelation
			var e data.MediaRelation
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed MediaRelation
			err = g.Service.Create(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// UpdateHandler returns a PUT endpoint handler for
// updaing the MediaRelation with the given id (path variable :id)
func (g *MediaRelationHandlerGroup) UpdateHandler() Handler {
	return Handler{
		Method: http.MethodPut,
		Path:   []string{strings.ToLower("MediaRelation"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into MediaRelation
			var e data.MediaRelation
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed MediaRelation
			err = g.Service.Update(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// DeleteHandler returns a DELETE endpoint handler for
// deleting the MediaRelation at the given id (path variable :id)
func (g *MediaRelationHandlerGroup) DeleteHandler() Handler {
	return Handler{
		Method: http.MethodDelete,
		Path:   []string{strings.ToLower("MediaRelation"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Delete by ID and retrieve existing
			e, err := g.Service.Delete(id)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)

		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetAllHandler returns a GET endpoint handler for
// retrieving all MediaRelation
func (g *MediaRelationHandlerGroup) GetAllHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("MediaRelation")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Retrieve all MediaRelation
			list, err := g.Service.GetAll()
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}
			if list == nil {
				list = []data.MediaRelation{}
			}

			// Encode response
			encodeResponseBody(list, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetByIDHandler returns a GET endpoint handler for
// retrieving a single MediaRelation by the given id (path
// variable :id)
func (g *MediaRelationHandlerGroup) GetByIDHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("MediaRelation"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID from path
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Retrieve MediaRelation by ID
			e := data.MediaRelation{
				ID: id,
			}
			err = g.Service.GetByID(&e)
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// MediaCharacter is a generic placeholder for all entity types;
// it is assumed that MediaCharacter structs have an ID and Version,

// MediaCharacterHandlerGroup is a basic handler group for MediaCharacter
type MediaCharacterHandlerGroup struct {
	Service *data.MediaCharacterService
}

// NewMediaCharacterHandlerGroup returns a handler group for
// MediaCharacter with the given service
func NewMediaCharacterHandlerGroup(service *data.MediaCharacterService) MediaCharacterHandlerGroup {
	g := MediaCharacterHandlerGroup{
		Service: service,
	}
	return g
}

// Handlers returns all the basic CRUD handlers for the
// handler group
func (g *MediaCharacterHandlerGroup) Handlers() []Handler {
	return []Handler{
		g.CreateHandler(),
		g.UpdateHandler(),
		g.DeleteHandler(),
		g.GetAllHandler(),
		g.GetByIDHandler(),
	}
}

// CreateHandler returns an POST endpoint handler
// for creating new MediaCharacter
func (g *MediaCharacterHandlerGroup) CreateHandler() Handler {
	return Handler{
		Method: http.MethodPost,
		Path:   []string{strings.ToLower("MediaCharacter")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into MediaCharacter
			var e data.MediaCharacter
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed MediaCharacter
			err = g.Service.Create(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// UpdateHandler returns a PUT endpoint handler for
// updaing the MediaCharacter with the given id (path variable :id)
func (g *MediaCharacterHandlerGroup) UpdateHandler() Handler {
	return Handler{
		Method: http.MethodPut,
		Path:   []string{strings.ToLower("MediaCharacter"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into MediaCharacter
			var e data.MediaCharacter
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed MediaCharacter
			err = g.Service.Update(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// DeleteHandler returns a DELETE endpoint handler for
// deleting the MediaCharacter at the given id (path variable :id)
func (g *MediaCharacterHandlerGroup) DeleteHandler() Handler {
	return Handler{
		Method: http.MethodDelete,
		Path:   []string{strings.ToLower("MediaCharacter"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Delete by ID and retrieve existing
			e, err := g.Service.Delete(id)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)

		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetAllHandler returns a GET endpoint handler for
// retrieving all MediaCharacter
func (g *MediaCharacterHandlerGroup) GetAllHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("MediaCharacter")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Retrieve all MediaCharacter
			list, err := g.Service.GetAll()
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}
			if list == nil {
				list = []data.MediaCharacter{}
			}

			// Encode response
			encodeResponseBody(list, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetByIDHandler returns a GET endpoint handler for
// retrieving a single MediaCharacter by the given id (path
// variable :id)
func (g *MediaCharacterHandlerGroup) GetByIDHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("MediaCharacter"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID from path
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Retrieve MediaCharacter by ID
			e := data.MediaCharacter{
				ID: id,
			}
			err = g.Service.GetByID(&e)
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// MediaGenre is a generic placeholder for all entity types;
// it is assumed that MediaGenre structs have an ID and Version,

// MediaGenreHandlerGroup is a basic handler group for MediaGenre
type MediaGenreHandlerGroup struct {
	Service *data.MediaGenreService
}

// NewMediaGenreHandlerGroup returns a handler group for
// MediaGenre with the given service
func NewMediaGenreHandlerGroup(service *data.MediaGenreService) MediaGenreHandlerGroup {
	g := MediaGenreHandlerGroup{
		Service: service,
	}
	return g
}

// Handlers returns all the basic CRUD handlers for the
// handler group
func (g *MediaGenreHandlerGroup) Handlers() []Handler {
	return []Handler{
		g.CreateHandler(),
		g.UpdateHandler(),
		g.DeleteHandler(),
		g.GetAllHandler(),
		g.GetByIDHandler(),
	}
}

// CreateHandler returns an POST endpoint handler
// for creating new MediaGenre
func (g *MediaGenreHandlerGroup) CreateHandler() Handler {
	return Handler{
		Method: http.MethodPost,
		Path:   []string{strings.ToLower("MediaGenre")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into MediaGenre
			var e data.MediaGenre
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed MediaGenre
			err = g.Service.Create(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// UpdateHandler returns a PUT endpoint handler for
// updaing the MediaGenre with the given id (path variable :id)
func (g *MediaGenreHandlerGroup) UpdateHandler() Handler {
	return Handler{
		Method: http.MethodPut,
		Path:   []string{strings.ToLower("MediaGenre"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into MediaGenre
			var e data.MediaGenre
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed MediaGenre
			err = g.Service.Update(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// DeleteHandler returns a DELETE endpoint handler for
// deleting the MediaGenre at the given id (path variable :id)
func (g *MediaGenreHandlerGroup) DeleteHandler() Handler {
	return Handler{
		Method: http.MethodDelete,
		Path:   []string{strings.ToLower("MediaGenre"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Delete by ID and retrieve existing
			e, err := g.Service.Delete(id)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)

		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetAllHandler returns a GET endpoint handler for
// retrieving all MediaGenre
func (g *MediaGenreHandlerGroup) GetAllHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("MediaGenre")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Retrieve all MediaGenre
			list, err := g.Service.GetAll()
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}
			if list == nil {
				list = []data.MediaGenre{}
			}

			// Encode response
			encodeResponseBody(list, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetByIDHandler returns a GET endpoint handler for
// retrieving a single MediaGenre by the given id (path
// variable :id)
func (g *MediaGenreHandlerGroup) GetByIDHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("MediaGenre"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID from path
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Retrieve MediaGenre by ID
			e := data.MediaGenre{
				ID: id,
			}
			err = g.Service.GetByID(&e)
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// MediaProducer is a generic placeholder for all entity types;
// it is assumed that MediaProducer structs have an ID and Version,

// MediaProducerHandlerGroup is a basic handler group for MediaProducer
type MediaProducerHandlerGroup struct {
	Service *data.MediaProducerService
}

// NewMediaProducerHandlerGroup returns a handler group for
// MediaProducer with the given service
func NewMediaProducerHandlerGroup(service *data.MediaProducerService) MediaProducerHandlerGroup {
	g := MediaProducerHandlerGroup{
		Service: service,
	}
	return g
}

// Handlers returns all the basic CRUD handlers for the
// handler group
func (g *MediaProducerHandlerGroup) Handlers() []Handler {
	return []Handler{
		g.CreateHandler(),
		g.UpdateHandler(),
		g.DeleteHandler(),
		g.GetAllHandler(),
		g.GetByIDHandler(),
	}
}

// CreateHandler returns an POST endpoint handler
// for creating new MediaProducer
func (g *MediaProducerHandlerGroup) CreateHandler() Handler {
	return Handler{
		Method: http.MethodPost,
		Path:   []string{strings.ToLower("MediaProducer")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into MediaProducer
			var e data.MediaProducer
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed MediaProducer
			err = g.Service.Create(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// UpdateHandler returns a PUT endpoint handler for
// updaing the MediaProducer with the given id (path variable :id)
func (g *MediaProducerHandlerGroup) UpdateHandler() Handler {
	return Handler{
		Method: http.MethodPut,
		Path:   []string{strings.ToLower("MediaProducer"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into MediaProducer
			var e data.MediaProducer
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed MediaProducer
			err = g.Service.Update(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// DeleteHandler returns a DELETE endpoint handler for
// deleting the MediaProducer at the given id (path variable :id)
func (g *MediaProducerHandlerGroup) DeleteHandler() Handler {
	return Handler{
		Method: http.MethodDelete,
		Path:   []string{strings.ToLower("MediaProducer"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Delete by ID and retrieve existing
			e, err := g.Service.Delete(id)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)

		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetAllHandler returns a GET endpoint handler for
// retrieving all MediaProducer
func (g *MediaProducerHandlerGroup) GetAllHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("MediaProducer")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Retrieve all MediaProducer
			list, err := g.Service.GetAll()
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}
			if list == nil {
				list = []data.MediaProducer{}
			}

			// Encode response
			encodeResponseBody(list, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetByIDHandler returns a GET endpoint handler for
// retrieving a single MediaProducer by the given id (path
// variable :id)
func (g *MediaProducerHandlerGroup) GetByIDHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("MediaProducer"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID from path
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Retrieve MediaProducer by ID
			e := data.MediaProducer{
				ID: id,
			}
			err = g.Service.GetByID(&e)
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// UserMedia is a generic placeholder for all entity types;
// it is assumed that UserMedia structs have an ID and Version,

// UserMediaHandlerGroup is a basic handler group for UserMedia
type UserMediaHandlerGroup struct {
	Service *data.UserMediaService
}

// NewUserMediaHandlerGroup returns a handler group for
// UserMedia with the given service
func NewUserMediaHandlerGroup(service *data.UserMediaService) UserMediaHandlerGroup {
	g := UserMediaHandlerGroup{
		Service: service,
	}
	return g
}

// Handlers returns all the basic CRUD handlers for the
// handler group
func (g *UserMediaHandlerGroup) Handlers() []Handler {
	return []Handler{
		g.CreateHandler(),
		g.UpdateHandler(),
		g.DeleteHandler(),
		g.GetAllHandler(),
		g.GetByIDHandler(),
	}
}

// CreateHandler returns an POST endpoint handler
// for creating new UserMedia
func (g *UserMediaHandlerGroup) CreateHandler() Handler {
	return Handler{
		Method: http.MethodPost,
		Path:   []string{strings.ToLower("UserMedia")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into UserMedia
			var e data.UserMedia
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed UserMedia
			err = g.Service.Create(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// UpdateHandler returns a PUT endpoint handler for
// updaing the UserMedia with the given id (path variable :id)
func (g *UserMediaHandlerGroup) UpdateHandler() Handler {
	return Handler{
		Method: http.MethodPut,
		Path:   []string{strings.ToLower("UserMedia"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into UserMedia
			var e data.UserMedia
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed UserMedia
			err = g.Service.Update(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// DeleteHandler returns a DELETE endpoint handler for
// deleting the UserMedia at the given id (path variable :id)
func (g *UserMediaHandlerGroup) DeleteHandler() Handler {
	return Handler{
		Method: http.MethodDelete,
		Path:   []string{strings.ToLower("UserMedia"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Delete by ID and retrieve existing
			e, err := g.Service.Delete(id)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)

		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetAllHandler returns a GET endpoint handler for
// retrieving all UserMedia
func (g *UserMediaHandlerGroup) GetAllHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("UserMedia")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Retrieve all UserMedia
			list, err := g.Service.GetAll()
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}
			if list == nil {
				list = []data.UserMedia{}
			}

			// Encode response
			encodeResponseBody(list, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetByIDHandler returns a GET endpoint handler for
// retrieving a single UserMedia by the given id (path
// variable :id)
func (g *UserMediaHandlerGroup) GetByIDHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("UserMedia"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID from path
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Retrieve UserMedia by ID
			e := data.UserMedia{
				ID: id,
			}
			err = g.Service.GetByID(&e)
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// UserMediaList is a generic placeholder for all entity types;
// it is assumed that UserMediaList structs have an ID and Version,

// UserMediaListHandlerGroup is a basic handler group for UserMediaList
type UserMediaListHandlerGroup struct {
	Service *data.UserMediaListService
}

// NewUserMediaListHandlerGroup returns a handler group for
// UserMediaList with the given service
func NewUserMediaListHandlerGroup(service *data.UserMediaListService) UserMediaListHandlerGroup {
	g := UserMediaListHandlerGroup{
		Service: service,
	}
	return g
}

// Handlers returns all the basic CRUD handlers for the
// handler group
func (g *UserMediaListHandlerGroup) Handlers() []Handler {
	return []Handler{
		g.CreateHandler(),
		g.UpdateHandler(),
		g.DeleteHandler(),
		g.GetAllHandler(),
		g.GetByIDHandler(),
	}
}

// CreateHandler returns an POST endpoint handler
// for creating new UserMediaList
func (g *UserMediaListHandlerGroup) CreateHandler() Handler {
	return Handler{
		Method: http.MethodPost,
		Path:   []string{strings.ToLower("UserMediaList")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into UserMediaList
			var e data.UserMediaList
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed UserMediaList
			err = g.Service.Create(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// UpdateHandler returns a PUT endpoint handler for
// updaing the UserMediaList with the given id (path variable :id)
func (g *UserMediaListHandlerGroup) UpdateHandler() Handler {
	return Handler{
		Method: http.MethodPut,
		Path:   []string{strings.ToLower("UserMediaList"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Read request body
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				encodeError(api.RequestBodyReadingError, err, w)
				return
			}

			// Parse request body into UserMediaList
			var e data.UserMediaList
			err = json.Unmarshal(body, &e)
			if err != nil {
				encodeError(api.RequestBodyParsingError, err, w)
				return
			}

			// Persist parsed UserMediaList
			err = g.Service.Update(&e)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// DeleteHandler returns a DELETE endpoint handler for
// deleting the UserMediaList at the given id (path variable :id)
func (g *UserMediaListHandlerGroup) DeleteHandler() Handler {
	return Handler{
		Method: http.MethodDelete,
		Path:   []string{strings.ToLower("UserMediaList"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Delete by ID and retrieve existing
			e, err := g.Service.Delete(id)
			if err != nil {
				encodeError(api.DatabasePersistingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)

		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetAllHandler returns a GET endpoint handler for
// retrieving all UserMediaList
func (g *UserMediaListHandlerGroup) GetAllHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("UserMediaList")},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Retrieve all UserMediaList
			list, err := g.Service.GetAll()
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}
			if list == nil {
				list = []data.UserMediaList{}
			}

			// Encode response
			encodeResponseBody(list, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}

// GetByIDHandler returns a GET endpoint handler for
// retrieving a single UserMediaList by the given id (path
// variable :id)
func (g *UserMediaListHandlerGroup) GetByIDHandler() Handler {
	return Handler{
		Method: http.MethodGet,
		Path:   []string{strings.ToLower("UserMediaList"), ":id"},
		Logic: func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
			// Parse ID from path
			id, err := parsePathVarInteger(&ps, "id")
			if err != nil {
				encodeError(api.PathVariableParsingError, err, w)
				return
			}

			// Retrieve UserMediaList by ID
			e := data.UserMediaList{
				ID: id,
			}
			err = g.Service.GetByID(&e)
			if err != nil {
				encodeError(api.DatabaseQueryingError, err, w)
				return
			}

			// Encode response
			encodeResponseBody(e, w)
		},
		ResponseHeaders: map[string]string{
			HeaderContentType: HeaderContentTypeValJSON,
		},
	}
}
