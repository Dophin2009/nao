// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package data

import (
	"encoding/json"

	bolt "go.etcd.io/bbolt"
)

// Media is a generic placeholder for all entity types;
// it is assumed that Media structs have an ID and Version,

// MediaService is a struct that performs
// CRUD operations on the persistence layer.
type MediaService struct {
	DB *bolt.DB
}

// MediaBucketName represents the database bucket
// name for the bucket that stores Media instances
const MediaBucketName = "Media"

// GetByID retrieves a single isntance of Media
// with the given ID.
func (ser *MediaService) GetByID(e *Media) (err error) {
	v, err := GetByID(e.ID, MediaBucketName, ser.DB)
	if err != nil {
		return err
	}

	err = json.Unmarshal(v, e)
	if err != nil {
		return err
	}
	return
}

// GetAll retrieves all persisted instances of
// Media.
func (ser *MediaService) GetAll() (list []Media, err error) {
	return ser.GetFilter(func(e *Media) bool { return true })
}

// GetFilter retrieves all persisted instances of
// Media that pass the filter.
func (ser *MediaService) GetFilter(keep func(e *Media) bool) (list []Media, err error) {
	vlist, err := GetAll(MediaBucketName, ser.DB)
	for _, v := range vlist {
		var e Media
		err = json.Unmarshal(v, &e)
		if err != nil {
			return nil, err
		}

		if keep(&e) {
			list = append(list, e)
		}
	}
	return
}

// Create persists a new instance of Media to the database.
func (ser *MediaService) Create(e *Media) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(MediaBucketName, tx)
		if err != nil {
			return err
		}

		// Get next ID in sequence and
		// assign to entity
		id, err := b.NextSequence()
		if err != nil {
			return err
		}
		e.ID = int(id)
		e.Version = 0

		// Save entity in bucket
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(int(id)), buf)
	})
}

// Update replaces the persisted instance
// of Media with the given Media of
// the same ID.
func (ser *MediaService) Update(e *Media) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Check if entity with ID exists
		v, err := GetByID(e.ID, MediaBucketName, ser.DB)
		if err != nil {
			return err
		}
		var o Media
		err = json.Unmarshal(v, &o)
		if err != nil {
			return err
		}

		// Get bucket, exit if error
		b, err := Bucket(MediaBucketName, tx)
		if err != nil {
			return err
		}

		// Replace properties of new with certain
		// ones of old
		e.Version = o.Version + 1

		// Save Entity
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(e.ID), buf)
	})
}

// Delete removes the persisted instance
// of Media with the given ID
func (ser *MediaService) Delete(ID int) (e Media, err error) {
	err = ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(MediaBucketName, tx)
		if err != nil {
			return err
		}

		// Store existing to return
		e.ID = ID
		err = ser.GetByID(&e)
		if err != nil {
			return err
		}

		// Delete
		return b.Delete(itob(ID))
	})
	return
}

// Episode is a generic placeholder for all entity types;
// it is assumed that Episode structs have an ID and Version,

// EpisodeService is a struct that performs
// CRUD operations on the persistence layer.
type EpisodeService struct {
	DB *bolt.DB
}

// EpisodeBucketName represents the database bucket
// name for the bucket that stores Episode instances
const EpisodeBucketName = "Episode"

// GetByID retrieves a single isntance of Episode
// with the given ID.
func (ser *EpisodeService) GetByID(e *Episode) (err error) {
	v, err := GetByID(e.ID, EpisodeBucketName, ser.DB)
	if err != nil {
		return err
	}

	err = json.Unmarshal(v, e)
	if err != nil {
		return err
	}
	return
}

// GetAll retrieves all persisted instances of
// Episode.
func (ser *EpisodeService) GetAll() (list []Episode, err error) {
	return ser.GetFilter(func(e *Episode) bool { return true })
}

// GetFilter retrieves all persisted instances of
// Episode that pass the filter.
func (ser *EpisodeService) GetFilter(keep func(e *Episode) bool) (list []Episode, err error) {
	vlist, err := GetAll(EpisodeBucketName, ser.DB)
	for _, v := range vlist {
		var e Episode
		err = json.Unmarshal(v, &e)
		if err != nil {
			return nil, err
		}

		if keep(&e) {
			list = append(list, e)
		}
	}
	return
}

// Create persists a new instance of Episode to the database.
func (ser *EpisodeService) Create(e *Episode) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(EpisodeBucketName, tx)
		if err != nil {
			return err
		}

		// Get next ID in sequence and
		// assign to entity
		id, err := b.NextSequence()
		if err != nil {
			return err
		}
		e.ID = int(id)
		e.Version = 0

		// Save entity in bucket
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(int(id)), buf)
	})
}

// Update replaces the persisted instance
// of Episode with the given Episode of
// the same ID.
func (ser *EpisodeService) Update(e *Episode) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Check if entity with ID exists
		v, err := GetByID(e.ID, EpisodeBucketName, ser.DB)
		if err != nil {
			return err
		}
		var o Episode
		err = json.Unmarshal(v, &o)
		if err != nil {
			return err
		}

		// Get bucket, exit if error
		b, err := Bucket(EpisodeBucketName, tx)
		if err != nil {
			return err
		}

		// Replace properties of new with certain
		// ones of old
		e.Version = o.Version + 1

		// Save Entity
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(e.ID), buf)
	})
}

// Delete removes the persisted instance
// of Episode with the given ID
func (ser *EpisodeService) Delete(ID int) (e Episode, err error) {
	err = ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(EpisodeBucketName, tx)
		if err != nil {
			return err
		}

		// Store existing to return
		e.ID = ID
		err = ser.GetByID(&e)
		if err != nil {
			return err
		}

		// Delete
		return b.Delete(itob(ID))
	})
	return
}

// Character is a generic placeholder for all entity types;
// it is assumed that Character structs have an ID and Version,

// CharacterService is a struct that performs
// CRUD operations on the persistence layer.
type CharacterService struct {
	DB *bolt.DB
}

// CharacterBucketName represents the database bucket
// name for the bucket that stores Character instances
const CharacterBucketName = "Character"

// GetByID retrieves a single isntance of Character
// with the given ID.
func (ser *CharacterService) GetByID(e *Character) (err error) {
	v, err := GetByID(e.ID, CharacterBucketName, ser.DB)
	if err != nil {
		return err
	}

	err = json.Unmarshal(v, e)
	if err != nil {
		return err
	}
	return
}

// GetAll retrieves all persisted instances of
// Character.
func (ser *CharacterService) GetAll() (list []Character, err error) {
	return ser.GetFilter(func(e *Character) bool { return true })
}

// GetFilter retrieves all persisted instances of
// Character that pass the filter.
func (ser *CharacterService) GetFilter(keep func(e *Character) bool) (list []Character, err error) {
	vlist, err := GetAll(CharacterBucketName, ser.DB)
	for _, v := range vlist {
		var e Character
		err = json.Unmarshal(v, &e)
		if err != nil {
			return nil, err
		}

		if keep(&e) {
			list = append(list, e)
		}
	}
	return
}

// Create persists a new instance of Character to the database.
func (ser *CharacterService) Create(e *Character) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(CharacterBucketName, tx)
		if err != nil {
			return err
		}

		// Get next ID in sequence and
		// assign to entity
		id, err := b.NextSequence()
		if err != nil {
			return err
		}
		e.ID = int(id)
		e.Version = 0

		// Save entity in bucket
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(int(id)), buf)
	})
}

// Update replaces the persisted instance
// of Character with the given Character of
// the same ID.
func (ser *CharacterService) Update(e *Character) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Check if entity with ID exists
		v, err := GetByID(e.ID, CharacterBucketName, ser.DB)
		if err != nil {
			return err
		}
		var o Character
		err = json.Unmarshal(v, &o)
		if err != nil {
			return err
		}

		// Get bucket, exit if error
		b, err := Bucket(CharacterBucketName, tx)
		if err != nil {
			return err
		}

		// Replace properties of new with certain
		// ones of old
		e.Version = o.Version + 1

		// Save Entity
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(e.ID), buf)
	})
}

// Delete removes the persisted instance
// of Character with the given ID
func (ser *CharacterService) Delete(ID int) (e Character, err error) {
	err = ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(CharacterBucketName, tx)
		if err != nil {
			return err
		}

		// Store existing to return
		e.ID = ID
		err = ser.GetByID(&e)
		if err != nil {
			return err
		}

		// Delete
		return b.Delete(itob(ID))
	})
	return
}

// Genre is a generic placeholder for all entity types;
// it is assumed that Genre structs have an ID and Version,

// GenreService is a struct that performs
// CRUD operations on the persistence layer.
type GenreService struct {
	DB *bolt.DB
}

// GenreBucketName represents the database bucket
// name for the bucket that stores Genre instances
const GenreBucketName = "Genre"

// GetByID retrieves a single isntance of Genre
// with the given ID.
func (ser *GenreService) GetByID(e *Genre) (err error) {
	v, err := GetByID(e.ID, GenreBucketName, ser.DB)
	if err != nil {
		return err
	}

	err = json.Unmarshal(v, e)
	if err != nil {
		return err
	}
	return
}

// GetAll retrieves all persisted instances of
// Genre.
func (ser *GenreService) GetAll() (list []Genre, err error) {
	return ser.GetFilter(func(e *Genre) bool { return true })
}

// GetFilter retrieves all persisted instances of
// Genre that pass the filter.
func (ser *GenreService) GetFilter(keep func(e *Genre) bool) (list []Genre, err error) {
	vlist, err := GetAll(GenreBucketName, ser.DB)
	for _, v := range vlist {
		var e Genre
		err = json.Unmarshal(v, &e)
		if err != nil {
			return nil, err
		}

		if keep(&e) {
			list = append(list, e)
		}
	}
	return
}

// Create persists a new instance of Genre to the database.
func (ser *GenreService) Create(e *Genre) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(GenreBucketName, tx)
		if err != nil {
			return err
		}

		// Get next ID in sequence and
		// assign to entity
		id, err := b.NextSequence()
		if err != nil {
			return err
		}
		e.ID = int(id)
		e.Version = 0

		// Save entity in bucket
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(int(id)), buf)
	})
}

// Update replaces the persisted instance
// of Genre with the given Genre of
// the same ID.
func (ser *GenreService) Update(e *Genre) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Check if entity with ID exists
		v, err := GetByID(e.ID, GenreBucketName, ser.DB)
		if err != nil {
			return err
		}
		var o Genre
		err = json.Unmarshal(v, &o)
		if err != nil {
			return err
		}

		// Get bucket, exit if error
		b, err := Bucket(GenreBucketName, tx)
		if err != nil {
			return err
		}

		// Replace properties of new with certain
		// ones of old
		e.Version = o.Version + 1

		// Save Entity
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(e.ID), buf)
	})
}

// Delete removes the persisted instance
// of Genre with the given ID
func (ser *GenreService) Delete(ID int) (e Genre, err error) {
	err = ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(GenreBucketName, tx)
		if err != nil {
			return err
		}

		// Store existing to return
		e.ID = ID
		err = ser.GetByID(&e)
		if err != nil {
			return err
		}

		// Delete
		return b.Delete(itob(ID))
	})
	return
}

// Producer is a generic placeholder for all entity types;
// it is assumed that Producer structs have an ID and Version,

// ProducerService is a struct that performs
// CRUD operations on the persistence layer.
type ProducerService struct {
	DB *bolt.DB
}

// ProducerBucketName represents the database bucket
// name for the bucket that stores Producer instances
const ProducerBucketName = "Producer"

// GetByID retrieves a single isntance of Producer
// with the given ID.
func (ser *ProducerService) GetByID(e *Producer) (err error) {
	v, err := GetByID(e.ID, ProducerBucketName, ser.DB)
	if err != nil {
		return err
	}

	err = json.Unmarshal(v, e)
	if err != nil {
		return err
	}
	return
}

// GetAll retrieves all persisted instances of
// Producer.
func (ser *ProducerService) GetAll() (list []Producer, err error) {
	return ser.GetFilter(func(e *Producer) bool { return true })
}

// GetFilter retrieves all persisted instances of
// Producer that pass the filter.
func (ser *ProducerService) GetFilter(keep func(e *Producer) bool) (list []Producer, err error) {
	vlist, err := GetAll(ProducerBucketName, ser.DB)
	for _, v := range vlist {
		var e Producer
		err = json.Unmarshal(v, &e)
		if err != nil {
			return nil, err
		}

		if keep(&e) {
			list = append(list, e)
		}
	}
	return
}

// Create persists a new instance of Producer to the database.
func (ser *ProducerService) Create(e *Producer) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(ProducerBucketName, tx)
		if err != nil {
			return err
		}

		// Get next ID in sequence and
		// assign to entity
		id, err := b.NextSequence()
		if err != nil {
			return err
		}
		e.ID = int(id)
		e.Version = 0

		// Save entity in bucket
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(int(id)), buf)
	})
}

// Update replaces the persisted instance
// of Producer with the given Producer of
// the same ID.
func (ser *ProducerService) Update(e *Producer) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Check if entity with ID exists
		v, err := GetByID(e.ID, ProducerBucketName, ser.DB)
		if err != nil {
			return err
		}
		var o Producer
		err = json.Unmarshal(v, &o)
		if err != nil {
			return err
		}

		// Get bucket, exit if error
		b, err := Bucket(ProducerBucketName, tx)
		if err != nil {
			return err
		}

		// Replace properties of new with certain
		// ones of old
		e.Version = o.Version + 1

		// Save Entity
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(e.ID), buf)
	})
}

// Delete removes the persisted instance
// of Producer with the given ID
func (ser *ProducerService) Delete(ID int) (e Producer, err error) {
	err = ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(ProducerBucketName, tx)
		if err != nil {
			return err
		}

		// Store existing to return
		e.ID = ID
		err = ser.GetByID(&e)
		if err != nil {
			return err
		}

		// Delete
		return b.Delete(itob(ID))
	})
	return
}

// Person is a generic placeholder for all entity types;
// it is assumed that Person structs have an ID and Version,

// PersonService is a struct that performs
// CRUD operations on the persistence layer.
type PersonService struct {
	DB *bolt.DB
}

// PersonBucketName represents the database bucket
// name for the bucket that stores Person instances
const PersonBucketName = "Person"

// GetByID retrieves a single isntance of Person
// with the given ID.
func (ser *PersonService) GetByID(e *Person) (err error) {
	v, err := GetByID(e.ID, PersonBucketName, ser.DB)
	if err != nil {
		return err
	}

	err = json.Unmarshal(v, e)
	if err != nil {
		return err
	}
	return
}

// GetAll retrieves all persisted instances of
// Person.
func (ser *PersonService) GetAll() (list []Person, err error) {
	return ser.GetFilter(func(e *Person) bool { return true })
}

// GetFilter retrieves all persisted instances of
// Person that pass the filter.
func (ser *PersonService) GetFilter(keep func(e *Person) bool) (list []Person, err error) {
	vlist, err := GetAll(PersonBucketName, ser.DB)
	for _, v := range vlist {
		var e Person
		err = json.Unmarshal(v, &e)
		if err != nil {
			return nil, err
		}

		if keep(&e) {
			list = append(list, e)
		}
	}
	return
}

// Create persists a new instance of Person to the database.
func (ser *PersonService) Create(e *Person) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(PersonBucketName, tx)
		if err != nil {
			return err
		}

		// Get next ID in sequence and
		// assign to entity
		id, err := b.NextSequence()
		if err != nil {
			return err
		}
		e.ID = int(id)
		e.Version = 0

		// Save entity in bucket
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(int(id)), buf)
	})
}

// Update replaces the persisted instance
// of Person with the given Person of
// the same ID.
func (ser *PersonService) Update(e *Person) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Check if entity with ID exists
		v, err := GetByID(e.ID, PersonBucketName, ser.DB)
		if err != nil {
			return err
		}
		var o Person
		err = json.Unmarshal(v, &o)
		if err != nil {
			return err
		}

		// Get bucket, exit if error
		b, err := Bucket(PersonBucketName, tx)
		if err != nil {
			return err
		}

		// Replace properties of new with certain
		// ones of old
		e.Version = o.Version + 1

		// Save Entity
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(e.ID), buf)
	})
}

// Delete removes the persisted instance
// of Person with the given ID
func (ser *PersonService) Delete(ID int) (e Person, err error) {
	err = ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(PersonBucketName, tx)
		if err != nil {
			return err
		}

		// Store existing to return
		e.ID = ID
		err = ser.GetByID(&e)
		if err != nil {
			return err
		}

		// Delete
		return b.Delete(itob(ID))
	})
	return
}

// MediaRelation is a generic placeholder for all entity types;
// it is assumed that MediaRelation structs have an ID and Version,

// MediaRelationService is a struct that performs
// CRUD operations on the persistence layer.
type MediaRelationService struct {
	DB *bolt.DB
}

// MediaRelationBucketName represents the database bucket
// name for the bucket that stores MediaRelation instances
const MediaRelationBucketName = "MediaRelation"

// GetByID retrieves a single isntance of MediaRelation
// with the given ID.
func (ser *MediaRelationService) GetByID(e *MediaRelation) (err error) {
	v, err := GetByID(e.ID, MediaRelationBucketName, ser.DB)
	if err != nil {
		return err
	}

	err = json.Unmarshal(v, e)
	if err != nil {
		return err
	}
	return
}

// GetAll retrieves all persisted instances of
// MediaRelation.
func (ser *MediaRelationService) GetAll() (list []MediaRelation, err error) {
	return ser.GetFilter(func(e *MediaRelation) bool { return true })
}

// GetFilter retrieves all persisted instances of
// MediaRelation that pass the filter.
func (ser *MediaRelationService) GetFilter(keep func(e *MediaRelation) bool) (list []MediaRelation, err error) {
	vlist, err := GetAll(MediaRelationBucketName, ser.DB)
	for _, v := range vlist {
		var e MediaRelation
		err = json.Unmarshal(v, &e)
		if err != nil {
			return nil, err
		}

		if keep(&e) {
			list = append(list, e)
		}
	}
	return
}

// Create persists a new instance of MediaRelation to the database.
func (ser *MediaRelationService) Create(e *MediaRelation) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(MediaRelationBucketName, tx)
		if err != nil {
			return err
		}

		// Get next ID in sequence and
		// assign to entity
		id, err := b.NextSequence()
		if err != nil {
			return err
		}
		e.ID = int(id)
		e.Version = 0

		// Save entity in bucket
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(int(id)), buf)
	})
}

// Update replaces the persisted instance
// of MediaRelation with the given MediaRelation of
// the same ID.
func (ser *MediaRelationService) Update(e *MediaRelation) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Check if entity with ID exists
		v, err := GetByID(e.ID, MediaRelationBucketName, ser.DB)
		if err != nil {
			return err
		}
		var o MediaRelation
		err = json.Unmarshal(v, &o)
		if err != nil {
			return err
		}

		// Get bucket, exit if error
		b, err := Bucket(MediaRelationBucketName, tx)
		if err != nil {
			return err
		}

		// Replace properties of new with certain
		// ones of old
		e.Version = o.Version + 1

		// Save Entity
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(e.ID), buf)
	})
}

// Delete removes the persisted instance
// of MediaRelation with the given ID
func (ser *MediaRelationService) Delete(ID int) (e MediaRelation, err error) {
	err = ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(MediaRelationBucketName, tx)
		if err != nil {
			return err
		}

		// Store existing to return
		e.ID = ID
		err = ser.GetByID(&e)
		if err != nil {
			return err
		}

		// Delete
		return b.Delete(itob(ID))
	})
	return
}

// MediaCharacter is a generic placeholder for all entity types;
// it is assumed that MediaCharacter structs have an ID and Version,

// MediaCharacterService is a struct that performs
// CRUD operations on the persistence layer.
type MediaCharacterService struct {
	DB *bolt.DB
}

// MediaCharacterBucketName represents the database bucket
// name for the bucket that stores MediaCharacter instances
const MediaCharacterBucketName = "MediaCharacter"

// GetByID retrieves a single isntance of MediaCharacter
// with the given ID.
func (ser *MediaCharacterService) GetByID(e *MediaCharacter) (err error) {
	v, err := GetByID(e.ID, MediaCharacterBucketName, ser.DB)
	if err != nil {
		return err
	}

	err = json.Unmarshal(v, e)
	if err != nil {
		return err
	}
	return
}

// GetAll retrieves all persisted instances of
// MediaCharacter.
func (ser *MediaCharacterService) GetAll() (list []MediaCharacter, err error) {
	return ser.GetFilter(func(e *MediaCharacter) bool { return true })
}

// GetFilter retrieves all persisted instances of
// MediaCharacter that pass the filter.
func (ser *MediaCharacterService) GetFilter(keep func(e *MediaCharacter) bool) (list []MediaCharacter, err error) {
	vlist, err := GetAll(MediaCharacterBucketName, ser.DB)
	for _, v := range vlist {
		var e MediaCharacter
		err = json.Unmarshal(v, &e)
		if err != nil {
			return nil, err
		}

		if keep(&e) {
			list = append(list, e)
		}
	}
	return
}

// Create persists a new instance of MediaCharacter to the database.
func (ser *MediaCharacterService) Create(e *MediaCharacter) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(MediaCharacterBucketName, tx)
		if err != nil {
			return err
		}

		// Get next ID in sequence and
		// assign to entity
		id, err := b.NextSequence()
		if err != nil {
			return err
		}
		e.ID = int(id)
		e.Version = 0

		// Save entity in bucket
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(int(id)), buf)
	})
}

// Update replaces the persisted instance
// of MediaCharacter with the given MediaCharacter of
// the same ID.
func (ser *MediaCharacterService) Update(e *MediaCharacter) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Check if entity with ID exists
		v, err := GetByID(e.ID, MediaCharacterBucketName, ser.DB)
		if err != nil {
			return err
		}
		var o MediaCharacter
		err = json.Unmarshal(v, &o)
		if err != nil {
			return err
		}

		// Get bucket, exit if error
		b, err := Bucket(MediaCharacterBucketName, tx)
		if err != nil {
			return err
		}

		// Replace properties of new with certain
		// ones of old
		e.Version = o.Version + 1

		// Save Entity
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(e.ID), buf)
	})
}

// Delete removes the persisted instance
// of MediaCharacter with the given ID
func (ser *MediaCharacterService) Delete(ID int) (e MediaCharacter, err error) {
	err = ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(MediaCharacterBucketName, tx)
		if err != nil {
			return err
		}

		// Store existing to return
		e.ID = ID
		err = ser.GetByID(&e)
		if err != nil {
			return err
		}

		// Delete
		return b.Delete(itob(ID))
	})
	return
}

// MediaGenre is a generic placeholder for all entity types;
// it is assumed that MediaGenre structs have an ID and Version,

// MediaGenreService is a struct that performs
// CRUD operations on the persistence layer.
type MediaGenreService struct {
	DB *bolt.DB
}

// MediaGenreBucketName represents the database bucket
// name for the bucket that stores MediaGenre instances
const MediaGenreBucketName = "MediaGenre"

// GetByID retrieves a single isntance of MediaGenre
// with the given ID.
func (ser *MediaGenreService) GetByID(e *MediaGenre) (err error) {
	v, err := GetByID(e.ID, MediaGenreBucketName, ser.DB)
	if err != nil {
		return err
	}

	err = json.Unmarshal(v, e)
	if err != nil {
		return err
	}
	return
}

// GetAll retrieves all persisted instances of
// MediaGenre.
func (ser *MediaGenreService) GetAll() (list []MediaGenre, err error) {
	return ser.GetFilter(func(e *MediaGenre) bool { return true })
}

// GetFilter retrieves all persisted instances of
// MediaGenre that pass the filter.
func (ser *MediaGenreService) GetFilter(keep func(e *MediaGenre) bool) (list []MediaGenre, err error) {
	vlist, err := GetAll(MediaGenreBucketName, ser.DB)
	for _, v := range vlist {
		var e MediaGenre
		err = json.Unmarshal(v, &e)
		if err != nil {
			return nil, err
		}

		if keep(&e) {
			list = append(list, e)
		}
	}
	return
}

// Create persists a new instance of MediaGenre to the database.
func (ser *MediaGenreService) Create(e *MediaGenre) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(MediaGenreBucketName, tx)
		if err != nil {
			return err
		}

		// Get next ID in sequence and
		// assign to entity
		id, err := b.NextSequence()
		if err != nil {
			return err
		}
		e.ID = int(id)
		e.Version = 0

		// Save entity in bucket
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(int(id)), buf)
	})
}

// Update replaces the persisted instance
// of MediaGenre with the given MediaGenre of
// the same ID.
func (ser *MediaGenreService) Update(e *MediaGenre) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Check if entity with ID exists
		v, err := GetByID(e.ID, MediaGenreBucketName, ser.DB)
		if err != nil {
			return err
		}
		var o MediaGenre
		err = json.Unmarshal(v, &o)
		if err != nil {
			return err
		}

		// Get bucket, exit if error
		b, err := Bucket(MediaGenreBucketName, tx)
		if err != nil {
			return err
		}

		// Replace properties of new with certain
		// ones of old
		e.Version = o.Version + 1

		// Save Entity
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(e.ID), buf)
	})
}

// Delete removes the persisted instance
// of MediaGenre with the given ID
func (ser *MediaGenreService) Delete(ID int) (e MediaGenre, err error) {
	err = ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(MediaGenreBucketName, tx)
		if err != nil {
			return err
		}

		// Store existing to return
		e.ID = ID
		err = ser.GetByID(&e)
		if err != nil {
			return err
		}

		// Delete
		return b.Delete(itob(ID))
	})
	return
}

// MediaProducer is a generic placeholder for all entity types;
// it is assumed that MediaProducer structs have an ID and Version,

// MediaProducerService is a struct that performs
// CRUD operations on the persistence layer.
type MediaProducerService struct {
	DB *bolt.DB
}

// MediaProducerBucketName represents the database bucket
// name for the bucket that stores MediaProducer instances
const MediaProducerBucketName = "MediaProducer"

// GetByID retrieves a single isntance of MediaProducer
// with the given ID.
func (ser *MediaProducerService) GetByID(e *MediaProducer) (err error) {
	v, err := GetByID(e.ID, MediaProducerBucketName, ser.DB)
	if err != nil {
		return err
	}

	err = json.Unmarshal(v, e)
	if err != nil {
		return err
	}
	return
}

// GetAll retrieves all persisted instances of
// MediaProducer.
func (ser *MediaProducerService) GetAll() (list []MediaProducer, err error) {
	return ser.GetFilter(func(e *MediaProducer) bool { return true })
}

// GetFilter retrieves all persisted instances of
// MediaProducer that pass the filter.
func (ser *MediaProducerService) GetFilter(keep func(e *MediaProducer) bool) (list []MediaProducer, err error) {
	vlist, err := GetAll(MediaProducerBucketName, ser.DB)
	for _, v := range vlist {
		var e MediaProducer
		err = json.Unmarshal(v, &e)
		if err != nil {
			return nil, err
		}

		if keep(&e) {
			list = append(list, e)
		}
	}
	return
}

// Create persists a new instance of MediaProducer to the database.
func (ser *MediaProducerService) Create(e *MediaProducer) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(MediaProducerBucketName, tx)
		if err != nil {
			return err
		}

		// Get next ID in sequence and
		// assign to entity
		id, err := b.NextSequence()
		if err != nil {
			return err
		}
		e.ID = int(id)
		e.Version = 0

		// Save entity in bucket
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(int(id)), buf)
	})
}

// Update replaces the persisted instance
// of MediaProducer with the given MediaProducer of
// the same ID.
func (ser *MediaProducerService) Update(e *MediaProducer) (err error) {
	// Verify validity of struct
	err = ser.Validate(e)
	if err != nil {
		return err
	}

	return ser.DB.Update(func(tx *bolt.Tx) error {
		// Check if entity with ID exists
		v, err := GetByID(e.ID, MediaProducerBucketName, ser.DB)
		if err != nil {
			return err
		}
		var o MediaProducer
		err = json.Unmarshal(v, &o)
		if err != nil {
			return err
		}

		// Get bucket, exit if error
		b, err := Bucket(MediaProducerBucketName, tx)
		if err != nil {
			return err
		}

		// Replace properties of new with certain
		// ones of old
		e.Version = o.Version + 1

		// Save Entity
		buf, err := json.Marshal(e)
		if err != nil {
			return err
		}

		return b.Put(itob(e.ID), buf)
	})
}

// Delete removes the persisted instance
// of MediaProducer with the given ID
func (ser *MediaProducerService) Delete(ID int) (e MediaProducer, err error) {
	err = ser.DB.Update(func(tx *bolt.Tx) error {
		// Get bucket, exit if error
		b, err := Bucket(MediaProducerBucketName, tx)
		if err != nil {
			return err
		}

		// Store existing to return
		e.ID = ID
		err = ser.GetByID(&e)
		if err != nil {
			return err
		}

		// Delete
		return b.Delete(itob(ID))
	})
	return
}
